# Написать метод count_find_num, который принимает на вход список простых множителей (primesL) и целое число,
# предел (limit), после чего попробуйте сгенерировать по порядку все числа.
# Меньшие значения предела, которые имеют все и только простые множители простых чисел primesL.
#
# primesL = [2, 5, 7]
# limit = 500
# List of Numbers Under 500          Prime Factorization
# ___________________________________________________________
#            70                         [2, 5, 7]
#           140                         [2, 2, 5, 7]
#           280                         [2, 2, 2, 5, 7]
#           350                         [2, 5, 5, 7]
#           490                         [2, 5, 7, 7]
#
# Скопировать
# 5 из этих чисел меньше 500, а самое большое из них 490.

def count_find_num(primesL, limit):
    primes = []
    primes_new = []
    Max_primes = 0
    j = 0
    for i in range(limit):
        primes.append(i)
    for i in range(0, limit-1):
        if primes[i] % primesL[0] == 0 and primes[i] % primesL[1] == 0:
            primes_new.append(primes[i])
            print(primes_new)
    for i in range(1, (len(primes_new)-1)):
        if primes_new[i] > primes_new[i-1]:
            Max_primes = primes_new[i]
    return [len(primes_new)-1, Max_primes]

primesL = list(map( int, input().split()))
print(primesL)
limit = int(input())
print(limit)
print(count_find_num(primesL, limit))
